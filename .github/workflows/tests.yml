# GitHub Actions Workflow for Planet Wars
# This workflow runs automated tests to ensure code quality

name: Tests

# Triggers: When this workflow runs
on:
  # Run on every push to any branch
  push:
    branches: [ "**" ]
  
  # Run on every pull request to any branch
  pull_request:
    branches: [ "**" ]
  
  # Allow manual trigger from GitHub Actions tab
  workflow_dispatch:

# Jobs: The actual work to be done
jobs:
  # Job 1: Run all tests
  test:
    # Use Ubuntu (Linux) as the runner
    # GitHub provides: ubuntu-latest, windows-latest, macos-latest
    runs-on: ubuntu-latest
    
    # Strategy: Test on multiple Python versions (optional, currently just 3.11)
    strategy:
      matrix:
        python-version: ["3.11"]
    
    # Steps: Individual tasks that run sequentially
    steps:
      # Step 1: Check out the repository code
      - name: Checkout code
        uses: actions/checkout@v4
        # 'uses' means use a pre-built action from GitHub marketplace
        # checkout@v4 is the official action to clone your repo
      
      # Step 2: Set up Python environment
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
        # ${{ matrix.python-version }} is a variable from strategy.matrix
      
      # Step 3: Install system dependencies
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pygame ffmpeg libsdl2-mixer-2.0-0
        # 'run' executes shell commands
        # pygame needs SDL libraries, ffmpeg needed for audio processing
      
      # Step 4: Install pipenv
      - name: Install pipenv
        run: |
          python -m pip install --upgrade pip
          pip install pipenv
        # pipenv is not pre-installed, so we install it
      
      # Step 5: Install project dependencies
      - name: Install dependencies
        run: |
          pipenv install --dev
        # --dev installs both regular and development dependencies (pytest, etc.)
      
      # Step 6: Run unit tests with coverage
      - name: Run unit tests
        env:
          SDL_AUDIODRIVER: dummy
          SDL_VIDEODRIVER: dummy
        run: |
          pipenv run pytest tests/unit/ -v --tb=short --cov=game --cov-report=term
        # -v = verbose output
        # --tb=short = shorter traceback on failures
        # --cov=game measures code coverage while running tests (no re-run needed!)
        # --cov-report=term prints coverage summary to console
        # This step will FAIL the workflow if any test fails
        # SDL_AUDIODRIVER=dummy: Use fake audio device (no hardware needed)
        # SDL_VIDEODRIVER=dummy: Use fake display (no screen needed)
      
      # Step 7: Run integration tests (append to coverage)
      - name: Run integration tests
        env:
          SDL_AUDIODRIVER: dummy
          SDL_VIDEODRIVER: dummy
        run: |
          pipenv run pytest tests/integration/ -v --tb=short --cov=game --cov-append --cov-report=term --cov-report=xml
        # --cov-append adds to existing coverage data from unit tests
        # --cov-report=xml creates coverage.xml for upload
        # Separate step so you can see which test suite failed
        # SDL dummy drivers allow pygame to run without hardware
      
      # Step 8: Upload coverage to GitHub (optional, stays for 90 days)
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage.xml
        # Artifacts are files saved from the workflow
        # You can download them from GitHub Actions tab
        # if: always() means upload even if previous steps failed

